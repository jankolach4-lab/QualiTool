<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Geokodierung und Polygon-Zuweisung</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 10px; background: #f0f0f0; }
    #container { display: flex; gap: 10px; flex-wrap: wrap; height: calc(100vh - 20px); }
    #sidebar { width: 220px; max-height: calc(100vh - 20px); overflow: auto; }
    #map { height: 800px; width: 100%; flex: 1; border-radius: 10px; }
    .section { margin-bottom: 6px; padding: 6px; background: #fff; border-radius: 6px; box-shadow: 0 0 8px rgba(0,0,0,0.1); }
    input, select, button, textarea { padding: 6px; margin: 3px 0; width: 100%; box-sizing: border-box; font-size: 12px; }
    button { background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }
    button:hover { background: #45a049; }
    #weCount { font-weight: bold; margin-top: 3px; font-size: 12px; }
    #error { color: red; display: none; font-size: 12px; }
    #success { color: green; display: none; font-size: 12px; }
    #failedAddresses { display: none; margin-top: 3px; }
    #loading { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 4px; font-size: 12px; }
    .legend-item { display: flex; align-items: center; margin: 2px 0; font-size: 12px; }
    .legend-color { width: 12px; height: 12px; margin-right: 6px; border-radius: 50%; }
    .failed-address { margin: 3px 0; padding: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; }
    h3 { font-size: 14px; margin: 4px 0; }
    label { font-size: 12px; }
    p { font-size: 11px; margin: 2px 0; }
    .hint { font-size: 11px; color: #6b7280; }
    @media (max-width: 600px) {
      #container { flex-direction: column; height: auto; }
      #sidebar { width: 100%; max-height: 260px; }
      #map { height: 520px; width: 100%; }
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="sidebar">
      <div class="section">
        <h3>Legende</h3>
        <div class="legend-item"><div class="legend-color" style="background: #87CEEB;"></div>1 Wohneinheit</div>
        <div class="legend-item"><div class="legend-color" style="background: #0000FF;"></div>2 Wohneinheiten</div>
        <div class="legend-item"><div class="legend-color" style="background: #333333;"></div>3+ Wohneinheiten</div>
        <div class="legend-item"><div class="legend-color" style="background: #FF0000;"></div>Im Polygon</div>
      </div>
      <div class="section">
        <h3>Mitarbeiter</h3>
        <input type="text" id="employeeName" placeholder="Mitarbeitername">
        <button onclick="addEmployee()">Mitarbeiter hinzufügen</button>
        <select id="employeeSelect" onchange="updatePolygonAssignment()">
          <option value="">Mitarbeiter auswählen</option>
        </select>
      </div>
      <div class="section">
        <h3>Polygone</h3>
        <select id="polygonSelect" onchange="highlightPolygon()">
          <option value="">Polygon auswählen</option>
        </select>
        <button onclick="deleteSelectedPolygon()">Polygon löschen</button>
      </div>
      <div class="section">
        <h3>Excel-Import</h3>
        <input type="file" id="excelInput" accept=".xlsx,.xls">
        <button onclick="importExcel()">Datei importieren</button>
        <div class="hint">Erwartete Spalten (flexibel): PLZ, Ort, Straße/Strasse/Str., Nummer/Hausnummer, Zusatz (optional), WE/Wohneinheiten.</div>
        <div id="error"></div>
        <div id="success"></div>
        <div id="failedAddresses"></div>
      </div>
      <div class="section">
        <h3>Polygon-Zuweisung</h3>
        <button onclick="exportPolygonAddresses()">Adressen exportieren (CSV)</button>
        <button onclick="testCSVExport()">Test-CSV-Export</button>
        <div id="weCount">Wohneinheiten im Polygon: 0</div>
        <p>Falls kein Download startet, kopieren Sie die Daten aus dem Textfeld und speichern Sie sie in einer .csv-Datei.</p>
        <textarea id="csvOutput" rows="2" placeholder="CSV-Daten erscheinen hier, falls der Download fehlschlägt"></textarea>
      </div>
      <div class="section">
        <h3>Farben anpassen</h3>
        <label>Marker-Farbe (1 WE):</label>
        <input type="color" id="colorWE1" value="#87CEEB">
        <label>Marker-Farbe (2 WE):</label>
        <input type="color" id="colorWE2" value="#0000FF">
        <label>Marker-Farbe (3+ WE):</label>
        <input type="color" id="colorWE3" value="#333333">
        <button onclick="applyCustomColors()">Farben anwenden</button>
      </div>
      <div class="section">
        <h3>Datenverwaltung</h3>
        <button onclick="clearLocalStorage()">Daten löschen</button>
      </div>
    </div>
    <div id="map"></div>
  </div>
  <div id="loading">Adressen werden importiert...</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script>
    function showError(message) {
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
      setTimeout(() => errorDiv.style.display = 'none', 7000);
      console.error('Fehler:', message);
    }
    function showSuccess(message) {
      const successDiv = document.getElementById('success');
      successDiv.textContent = message;
      successDiv.style.display = 'block';
      setTimeout(() => successDiv.style.display = 'none', 6000);
      console.log('OK:', message);
    }

    let map;
    try {
      map = L.map('map').setView([51.1657, 10.4515], 6);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap', maxZoom: 19 }).addTo(map);
    } catch (e) { showError('Fehler beim Initialisieren der Karte: ' + (e.message || e)); }

    let drawnItems = new L.FeatureGroup();
    let markerClusterGroup = L.markerClusterGroup({ disableClusteringAtZoom: 15, maxClusterRadius: 50 });
    if (map) { map.addLayer(drawnItems); map.addLayer(markerClusterGroup); map.addControl(new L.Control.Draw({ draw: { polygon: true, polyline: false, rectangle: false, circle: false, marker: false, circlemarker: false }, edit: { featureGroup: drawnItems } })); }

    let addresses = []; let markers = []; let polygons = []; let employees = []; let failedAddresses = [];
    const polygonColors = ['#0000FF', '#008000', '#800080', '#FFA500', '#00CED1'];
    let colorWE1 = '#87CEEB', colorWE2 = '#0000FF', colorWE3 = '#333333';

    function loadFromLocalStorage() {
      try {
        const savedAddresses = localStorage.getItem('addresses');
        const savedEmployees = localStorage.getItem('employees');
        const savedPolygons = localStorage.getItem('polygons');
        if (savedAddresses) {
          addresses = JSON.parse(savedAddresses);
          addresses.forEach((addr, i) => {
            if (addr.lat && addr.lon && map) {
              const we = addr.WE; const color = we === 1 ? colorWE1 : we === 2 ? colorWE2 : colorWE3;
              const marker = L.circleMarker([addr.lat, addr.lon], { radius: 5, color, fillOpacity: 0.8 });
              marker.bindPopup(createPopupContent(addr, i)); markerClusterGroup.addLayer(marker); markers.push(marker); addr.originalColor = color;
            }
          });
          if (markers.length > 0 && map) map.fitBounds(markerClusterGroup.getBounds());
        }
        if (savedEmployees) { employees = JSON.parse(savedEmployees); updateEmployeeSelect(); }
        if (savedPolygons) {
          polygons = JSON.parse(savedPolygons);
          polygons.forEach((poly) => { const layer = L.polygon(poly.latlngs, { color: poly.color }).addTo(drawnItems); layer.employee = poly.employee; layer.polygonId = poly.polygonId; });
          updatePolygonSelect();
        }
        updateWohneinheitenCount();
      } catch (e) { showError('Fehler beim Laden: ' + (e.message || e)); }
    }

    function saveToLocalStorage() {
      try {
        localStorage.setItem('addresses', JSON.stringify(addresses));
        localStorage.setItem('employees', JSON.stringify(employees));
        localStorage.setItem('polygons', JSON.stringify(polygons.map(poly => ({ employee: poly.employee, latlngs: poly.layer.getLatLngs(), color: poly.layer.options.color, polygonId: poly.polygonId }))));
      } catch (e) { showError('Fehler beim Speichern: ' + (e.message || e)); }
    }

    function addEmployee() {
      const name = document.getElementById('employeeName').value.trim();
      if (!name) return showError('Bitte einen Mitarbeiternamen eingeben.');
      employees.push(name); updateEmployeeSelect(); document.getElementById('employeeName').value=''; saveToLocalStorage();
    }
    function updateEmployeeSelect() { const select = document.getElementById('employeeSelect'); select.innerHTML = '<option value="">Mitarbeiter auswählen</option>'; employees.forEach(name => { const o = document.createElement('option'); o.value = name; o.textContent = name; select.appendChild(o); }); }
    function updatePolygonSelect() { const select = document.getElementById('polygonSelect'); select.innerHTML = '<option value="">Polygon auswählen</option>'; polygons.forEach((p) => { const o = document.createElement('option'); o.value = p.polygonId; o.textContent = `Polygon für ${p.employee}`; select.appendChild(o); }); }

    function createPopupContent(addr, index) {
      const fullAddress = `${addr.Straße} ${addr.Nummer}${addr.Zusatz ? ' ' + addr.Zusatz : ''}, ${addr.PLZ} ${addr.Ort}, Deutschland`;
      return `<div><b>${fullAddress}</b><br>Wohneinheiten: ${addr.WE}<br>
        <select id="assignEmployee${index}"><option value="">Mitarbeiter auswählen</option>${employees.map(emp => `<option value="${emp}">${emp}</option>`).join('')}</select>
        <button onclick="assignEmployeeToAddress(${index})">Zuweisen</button><br>
        <button onclick="editAddress(${index})">Adresse bearbeiten</button></div>`;
    }
    function assignEmployeeToAddress(index){ const select = document.getElementById(`assignEmployee${index}`); const employee = select.value; if(!employee) return showError('Bitte einen Mitarbeiter auswählen.'); const polygon = polygons.find(p=>p.employee===employee); if(!polygon) return showError('Kein Polygon für diesen Mitarbeiter gefunden.'); const addr = addresses[index]; const isInside = isPointInPolygon(addr.lat, addr.lon, polygon.layer); if(!isInside) return showError('Adresse liegt nicht im Polygon dieses Mitarbeiters.'); addr.employee = employee; saveToLocalStorage(); showSuccess(`Adresse ${addr.Straße} ${addr.Nummer} wurde ${employee} zugewiesen.`); }
    function editAddress(index){ const addr=addresses[index]; const newPLZ=prompt('Neue PLZ:', addr.PLZ); const newOrt=prompt('Neuer Ort:', addr.Ort); const newStr=prompt('Neue Straße:', addr.Straße); const newNum=prompt('Neue Nummer:', addr.Nummer); const newZus=prompt('Neuer Zusatz:', addr.Zusatz); const newWE=prompt('Neue Wohneinheiten:', addr.WE); if(newPLZ&&newOrt&&newStr&&newNum&&newWE){ addr.PLZ=newPLZ; addr.Ort=newOrt; addr.Straße=newStr; addr.Nummer=newNum; addr.Zusatz=newZus||''; addr.WE=parseInt(newWE)||1; const fullAddress=`${addr.Straße} ${addr.Nummer}${addr.Zusatz?' '+addr.Zusatz:''}, ${addr.PLZ} ${addr.Ort}, Deutschland`; geocodeAddress(fullAddress, index, true); saveToLocalStorage(); } else { showError('Bitte alle Felder ausfüllen.'); } }

    async function geocodeAddress(fullAddress, index, updateMarker=false){ try{ const cached=localStorage.getItem(`geocode_${fullAddress}`); if(cached){ const loc=JSON.parse(cached); addresses[index].lat=loc.lat; addresses[index].lon=loc.lon; if(updateMarker&&markers[index]&&map){ const we=addresses[index].WE; const color=we===1?colorWE1:we===2?colorWE2:colorWE3; markers[index].setLatLng([loc.lat, loc.lon]); markers[index].setStyle({color}); markers[index].bindPopup(createPopupContent(addresses[index], index)); addresses[index].originalColor=color; } return true; } const response=await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(fullAddress)}&limit=1`,{ headers:{'User-Agent':'QualiDashboard-Polygontool/1.0 (contact: info@jl-dashboard.de)'} }); const loc=await response.json(); if(loc.length>0){ addresses[index].lat=parseFloat(loc[0].lat); addresses[index].lon=parseFloat(loc[0].lon); localStorage.setItem(`geocode_${fullAddress}`, JSON.stringify({lat:addresses[index].lat,lon:addresses[index].lon})); if(updateMarker&&markers[index]&&map){ const we=addresses[index].WE; const color=we===1?colorWE1:we===2?colorWE2:colorWE3; markers[index].setLatLng([addresses[index].lat, addresses[index].lon]); markers[index].setStyle({color}); markers[index].bindPopup(createPopupContent(addresses[index], index)); addresses[index].originalColor=color; } return true; } else { return false; } } catch(e){ console.error('Geocode error', e); return false; } }

    // === Toleranter Excel-Import ===
    function normalizeHeader(h){ if(!h) return ''; let s=String(h).trim().toLowerCase(); s=s.normalize('NFD').replace(/[\u0300-\u036f]/g,''); // diacritics raus
      s=s.replace(/\./g,'').replace(/\s+/g,' ');
      s=s.replace('strasse','straße'); // Sonderfall
      return s; }
    const aliasMap = {
      'plz':'PLZ','postleitzahl':'PLZ',
      'ort':'Ort','stadt':'Ort','gemeinde':'Ort',
      'straße':'Straße','strasse':'Straße','str':'Straße','strasse name':'Straße','strassenname':'Straße','strassenbezeichnung':'Straße','strassen':'Straße',
      'hausnummer':'Nummer','hnr':'Nummer','nr':'Nummer','nummer':'Nummer','haus nr':'Nummer','hausnr':'Nummer',
      'zusatz':'Zusatz','adresszusatz':'Zusatz','adresszus':'Zusatz','zus':'Zusatz','etage':'Zusatz','stock':'Zusatz',
      'we':'WE','wohneinheiten':'WE','wohneinheit':'WE','anz we':'WE','anzahl we':'WE','anzahl wohneinheiten':'WE'
    };
    function detectHeaderMap(rows){
      // rows: array of arrays
      const maxScan = Math.min(rows.length, 25);
      let best = { idx: -1, map: {}, score: -1 };
      for(let r=0;r<maxScan;r++){
        const row = rows[r] || [];
        const map = {}; let score = 0;
        row.forEach((cell, idx)=>{
          const n=normalizeHeader(cell); if(!n) return; const canon = aliasMap[n] || null; if(canon && !Object.values(map).includes(canon)){ map[idx]=canon; score++; }
        });
        if(score > best.score){ best = { idx:r, map, score } }
      }
      return best;
    }

    async function importExcel(){ const file = document.getElementById('excelInput').files[0]; if(!file) return showError('Bitte eine Excel-Datei auswählen.');
      try{
        document.getElementById('loading').style.display='block';
        markerClusterGroup.clearLayers(); markers=[]; addresses=[]; failedAddresses=[];
        const data = await file.arrayBuffer();
        const wb = XLSX.read(data, { type:'array' }); const sheet = wb.Sheets[wb.SheetNames[0]]; if(!sheet) throw new Error('Kein Arbeitsblatt gefunden.');
        const rows = XLSX.utils.sheet_to_json(sheet, { header:1, blankrows:false, defval:'' });
        if(!rows || rows.length===0) throw new Error('Leere Tabelle.');
        const best = detectHeaderMap(rows);
        const headerIdx = best.idx >= 0 ? best.idx : 0;
        const map = best.map || {};
        // Pflichtfelder (Zusatz optional)
        const required = ['PLZ','Ort','Straße','Nummer','WE'];
        const mappedCanon = new Set(Object.values(map));
        const missing = required.filter(k=>!mappedCanon.has(k));
        if(missing.length){
          // Versuche Fallback mit erster Zeile direkt
          const headerRow = rows[headerIdx];
          const headersDebug = (headerRow||[]).map(h=>String(h)).join(' | ');
          document.getElementById('loading').style.display='none';
          return showError('Spalten erkannt: '+Array.from(mappedCanon).join(', ')+' — Fehlend: '+missing.join(', ')+'\nHinweis: Mögliche Aliase: Straße/Strasse/Str., Nummer/Hausnummer, WE/Wohneinheiten.\nGefundene Kopfzeile: '+headersDebug);
        }
        // Zusatz optional: wenn nicht gemappt, bleibt undefined und wird als '' gesetzt
        // Baue Datensätze
        for(let r=headerIdx+1;r<rows.length;r++){
          const row = rows[r] || [];
          const obj = { PLZ:'', Ort:'', Straße:'', Nummer:'', Zusatz:'', WE:1 };
          Object.keys(map).forEach(colIdx=>{
            const canon = map[colIdx]; const val = row[Number(colIdx)];
            if(canon==='WE'){
              const n = parseInt(String(val).toString().replace(/[^0-9]/g,''),10);
              obj.WE = Number.isFinite(n) && n>0 ? n : 1; // Default 1
            } else if(canon){ obj[canon] = String(val||'').trim(); }
          });
          // Sanity: Mindestfelder müssen befüllt sein
          if(obj.PLZ||obj.Ort||obj.Straße||obj.Nummer){ addresses.push(obj); }
        }
        // Geokodierung batched
        let geocodedCount=0; const batchSize=10;
        for(let i=0;i<addresses.length;i+=batchSize){
          const batch = addresses.slice(i, i+batchSize);
          const promises = batch.map((address, j)=>{
            const fullAddress = `${address.Straße} ${address.Nummer}${address.Zusatz?' '+address.Zusatz:''}, ${address.PLZ} ${address.Ort}, Deutschland`;
            return geocodeAddress(fullAddress, i+j).then(success=>{ if(success && map){ const we=address.WE; const color=we===1?colorWE1:we===2?colorWE2:colorWE3; const marker=L.circleMarker([address.lat,address.lon],{radius:5,color,fillOpacity:0.8}); marker.bindPopup(createPopupContent(address,i+j)); markerClusterGroup.addLayer(marker); markers.push(marker); address.originalColor=color; geocodedCount++; } else { failedAddresses.push({ index:i+j, address }); } });
          });
          await Promise.all(promises);
          await new Promise(res=>setTimeout(res,1100));
        }
        if(failedAddresses.length>0) displayFailedAddresses();
        if(markers.length>0 && map){ map.fitBounds(markerClusterGroup.getBounds()); showSuccess(`Adressimport abgeschlossen: ${geocodedCount} Adressen auf der Karte.`); } else { showError('Keine Adressen konnten geokodiert werden.'); }
        saveToLocalStorage(); updateWohneinheitenCount(); document.getElementById('loading').style.display='none';
      } catch(e){ document.getElementById('loading').style.display='none'; showError('Fehler beim Verarbeiten der Excel-Datei: '+(e.message||e)); }
    }

    function displayFailedAddresses(){ const failedDiv=document.getElementById('failedAddresses'); failedDiv.innerHTML = '<h4 style="font-size: 12px; margin: 2px 0;">Nicht geokodierte Adressen</h4>'; failedAddresses.forEach(({index,address})=>{ const full=`${address.Straße} ${address.Nummer}${address.Zusatz?' '+address.Zusatz:''}, ${address.PLZ} ${address.Ort}, Deutschland`; const div=document.createElement('div'); div.className='failed-address'; div.innerHTML = `<p>${full}</p><input type="text" id="lat${index}" placeholder="Breitengrad"><input type="text" id="lon${index}" placeholder="Längengrad"><button onclick="addManualCoordinates(${index})">Hinzufügen</button><button onclick="skipAddress(${index})">Überspringen</button>`; failedDiv.appendChild(div); }); failedDiv.style.display='block'; }
    function addManualCoordinates(index){ const lat=parseFloat(document.getElementById(`lat${index}`).value); const lon=parseFloat(document.getElementById(`lon${index}`).value); if(isNaN(lat)||isNaN(lon)) return showError('Bitte gültige Koordinaten eingeben.'); const address=addresses[index]; address.lat=lat; address.lon=lon; const we=address.WE; const color=we===1?colorWE1:we===2?colorWE2:colorWE3; const marker=L.circleMarker([lat,lon],{radius:5,color,fillOpacity:0.8}); marker.bindPopup(createPopupContent(address,index)); markerClusterGroup.addLayer(marker); markers[index]=marker; address.originalColor=color; failedAddresses = failedAddresses.filter(f=>f.index!==index); if(failedAddresses.length===0) document.getElementById('failedAddresses').style.display='none'; else displayFailedAddresses(); saveToLocalStorage(); updateWohneinheitenCount(); showSuccess('Koordinaten hinzugefügt.'); }
    function skipAddress(index){ failedAddresses = failedAddresses.filter(f=>f.index!==index); if(failedAddresses.length===0) document.getElementById('failedAddresses').style.display='none'; else displayFailedAddresses(); }

    if(map){ map.on('draw:created', function(e){ const employee=document.getElementById('employeeSelect').value; if(!employee) return showError('Bitte einen Mitarbeiter auswählen, bevor ein Polygon gezeichnet wird.'); const layer=e.layer; const color=polygonColors[polygons.length % polygonColors.length]; layer.setStyle({color}); const polygonId=Date.now().toString(); layer.employee=employee; layer.polygonId=polygonId; polygons.push({ layer, employee, polygonId }); drawnItems.addLayer(layer); updatePolygonSelect(); saveToLocalStorage(); updateWohneinheitenCount(); }); map.on('draw:edited', function(){ saveToLocalStorage(); updateWohneinheitenCount(); }); }

    function highlightPolygon(){ const polygonId=document.getElementById('polygonSelect').value; polygons.forEach(p=>{ p.layer.setStyle({ weight: p.polygonId===polygonId ? 5 : 2 }); }); updateWohneinheitenCount(); }
    function deleteSelectedPolygon(){ const polygonId=document.getElementById('polygonSelect').value; if(!polygonId) return showError('Bitte ein Polygon auswählen.'); const index=polygons.findIndex(p=>p.polygonId===polygonId); if(index!==-1){ drawnItems.removeLayer(polygons[index].layer); polygons.splice(index,1); updatePolygonSelect(); saveToLocalStorage(); updateWohneinheitenCount(); } }

    function applyCustomColors(){ colorWE1=document.getElementById('colorWE1').value; colorWE2=document.getElementById('colorWE2').value; colorWE3=document.getElementById('colorWE3').value; addresses.forEach((addr,i)=>{ if(markers[i]){ const we=addr.WE; const color=we===1?colorWE1:we===2?colorWE2:colorWE3; addr.originalColor=color; const isInsideAny=polygons.some(p=>isPointInPolygon(addr.lat, addr.lon, p.layer)); if(!isInsideAny) markers[i].setStyle({color}); }}); saveToLocalStorage(); }
    function clearLocalStorage(){ localStorage.removeItem('addresses'); localStorage.removeItem('employees'); localStorage.removeItem('polygons'); addresses=[]; employees=[]; polygons=[]; markerClusterGroup.clearLayers(); markers=[]; drawnItems.clearLayers(); updateEmployeeSelect(); updatePolygonSelect(); updateWohneinheitenCount(); document.getElementById('failedAddresses').style.display='none'; }

    function isPointInPolygon(lat,lng,polygon){ try{ const point=L.latLng(lat,lng); const polyPoints=polygon.getLatLngs()[0]; const bounds=L.polygon(polyPoints).getBounds(); if(!bounds.contains(point)) return false; let inside=false; for(let i=0,j=polyPoints.length-1;i<polyPoints.length;j=i++){ const xi=polyPoints[i].lat, yi=polyPoints[i].lng; const xj=polyPoints[j].lat, yj=polyPoints[j].lng; const intersect=((yi>lng)!==(yj>lng)) && (lat < (xj - xi) * (lng - yi) / (yj - yi) + xi); if(intersect) inside=!inside; } return inside; } catch(e){ console.error('PointInPolygon error', e); return false; } }

    function updateWohneinheitenCount(){ const polygonId=document.getElementById('polygonSelect').value; const selectedPolygon=polygons.find(p=>p.polygonId===polygonId); if(!selectedPolygon){ document.getElementById('weCount').textContent='Wohneinheiten im Polygon: 0'; addresses.forEach((addr,i)=>{ if(markers[i]&&addr.originalColor) markers[i].setStyle({color:addr.originalColor}); }); return; } const coords=selectedPolygon.layer.getLatLngs()[0]; if(!coords||coords.length<3) return showError('Ungültiges Polygon: Mindestens 3 Punkte erforderlich.'); let totalWE=0; addresses.forEach((addr,i)=>{ if(addr.lat&&addr.lon){ const isInside=isPointInPolygon(addr.lat, addr.lon, selectedPolygon.layer); if(isInside){ totalWE += (Number.isFinite(addr.WE)?addr.WE:1); if(markers[i]) markers[i].setStyle({color:'#FF0000'}); } else { if(markers[i]&&addr.originalColor) markers[i].setStyle({color:addr.originalColor}); } } }); document.getElementById('weCount').textContent = `Wohneinheiten im Polygon: ${totalWE}`; }

    function testCSVExport(){ const dummy=[ {PLZ:'10115',Ort:'Berlin',Straße:'Hauptstraße',Nummer:'1',Zusatz:'A',WE:5}, {PLZ:'80331',Ort:'München',Straße:'Bahnhofstraße',Nummer:'10',Zusatz:'',WE:3} ]; exportAsCSV(dummy,'Test_Adressen.csv'); }
    function exportAsCSV(data, filename){ try{ const headers=['PLZ','Ort','Straße','Nummer','Zusatz','WE']; const esc=v=>{ if(v==null) return ''; return '"'+String(v).replace(/"/g,'""').replace(/\n/g,' ')+'"'; }; const csv=[ headers.join(','), ...data.map(r=>headers.map(h=>esc(r[h])).join(',')) ].join('\n'); const ta=document.getElementById('csvOutput'); ta.value=csv; ta.style.display='block'; const BOM='\uFEFF'; const blob=new Blob([BOM+csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const link=document.createElement('a'); link.href=url; link.download=filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); } catch(e){ showError('Fehler beim CSV-Export: '+(e.message||e)); } }
    function exportPolygonAddresses(){ const polygonId=document.getElementById('polygonSelect').value; if(!polygonId) return showError('Bitte ein Polygon auswählen.'); const polygon=polygons.find(p=>p.polygonId===polygonId); if(!polygon) return showError('Ausgewähltes Polygon nicht gefunden.'); const filtered=addresses.filter((addr,i)=> addr.lat&&addr.lon&&isPointInPolygon(addr.lat, addr.lon, polygon.layer)); if(filtered.length===0) return showError('Keine Adressen im Polygon gefunden.'); const exportData=filtered.map(addr=>({ PLZ:String(addr.PLZ||''), Ort:String(addr.Ort||''), Straße:String(addr.Straße||''), Nummer:String(addr.Nummer||''), Zusatz:String(addr.Zusatz||''), WE:Number.isFinite(addr.WE)?addr.WE:1 })); exportAsCSV(exportData, `${polygon.employee}_Adressen.csv`); }
    function updatePolygonAssignment(){ updateWohneinheitenCount(); }

    loadFromLocalStorage();
  </script>
</body>
</html>
