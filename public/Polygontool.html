<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Geokodierung und Polygon-Zuweisung</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 10px; background: #f0f0f0; }
    #container { display: flex; gap: 10px; flex-wrap: wrap; height: calc(100vh - 20px); }
    #sidebar { width: 220px; max-height: calc(100vh - 20px); overflow: auto; }
    #map { height: 800px; width: 100%; flex: 1; border-radius: 10px; }
    .section { margin-bottom: 6px; padding: 6px; background: #fff; border-radius: 6px; box-shadow: 0 0 8px rgba(0,0,0,0.1); }
    input, select, button, textarea { padding: 6px; margin: 3px 0; width: 100%; box-sizing: border-box; font-size: 12px; }
    button { background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }
    button:hover { background: #45a049; }
    #weCount { font-weight: bold; margin-top: 3px; font-size: 12px; }
    #error { color: red; display: none; font-size: 12px; }
    #success { color: green; display: none; font-size: 12px; }
    #failedAddresses { display: none; margin-top: 3px; }
    #loading { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 4px; font-size: 12px; }
    .legend-item { display: flex; align-items: center; margin: 2px 0; font-size: 12px; }
    .legend-color { width: 12px; height: 12px; margin-right: 6px; border-radius: 50%; }
    .failed-address { margin: 3px 0; padding: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; }
    h3 { font-size: 14px; margin: 4px 0; }
    label { font-size: 12px; }
    p { font-size: 11px; margin: 2px 0; }
    .hint { font-size: 11px; color: #6b7280; }
    @media (max-width: 600px) {
      #container { flex-direction: column; height: auto; }
      #sidebar { width: 100%; max-height: 260px; }
      #map { height: 520px; width: 100%; }
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="sidebar">
      <div class="section">
        <h3>Legende</h3>
        <div class="legend-item"><div class="legend-color" style="background: #87CEEB;"></div>1 Wohneinheit</div>
        <div class="legend-item"><div class="legend-color" style="background: #0000FF;"></div>2 Wohneinheiten</div>
        <div class="legend-item"><div class="legend-color" style="background: #333333;"></div>3+ Wohneinheiten</div>
        <div class="legend-item"><div class="legend-color" style="background: #FF0000;"></div>Im Polygon</div>
      </div>
      <div class="section">
        <h3>Mitarbeiter</h3>
        <input type="text" id="employeeName" placeholder="Mitarbeitername">
        <button onclick="addEmployee()">Mitarbeiter hinzufügen</button>
        <select id="employeeSelect" onchange="updatePolygonAssignment()">
          <option value="">Mitarbeiter auswählen</option>
        </select>
      </div>
      <div class="section">
        <h3>Polygone</h3>
        <select id="polygonSelect" onchange="highlightPolygon()">
          <option value="">Polygon auswählen</option>
        </select>
        <button onclick="deleteSelectedPolygon()">Polygon löschen</button>
      </div>
      <div class="section">
        <h3>Excel-Import</h3>
        <input type="file" id="excelInput" accept=".xlsx,.xls">
        <button onclick="importExcel()">Datei importieren</button>
        <div class="hint">Erwartete Spalten (flexibel): PLZ, Ort, Straße/Strasse/Str., Nummer/Hausnummer, Zusatz (optional), WE/Wohneinheiten.</div>
        <div id="error"></div>
        <div id="success"></div>
        <div id="failedAddresses"></div>
      </div>
      <div class="section">
        <h3>Polygon-Zuweisung</h3>
        <button onclick="exportPolygonAddresses()">Adressen exportieren (CSV)</button>
        <button onclick="testCSVExport()">Test-CSV-Export</button>
        <div id="weCount">Wohneinheiten im Polygon: 0</div>
        <p>Falls kein Download startet, kopieren Sie die Daten aus dem Textfeld und speichern Sie sie in einer .csv-Datei.</p>
        <textarea id="csvOutput" rows="2" placeholder="CSV-Daten erscheinen hier, falls der Download fehlschlägt"></textarea>
      </div>
      <div class="section">
        <h3>Farben anpassen</h3>
        <label>Marker-Farbe (1 WE):</label>
        <input type="color" id="colorWE1" value="#87CEEB">
        <label>Marker-Farbe (2 WE):</label>
        <input type="color" id="colorWE2" value="#0000FF">
        <label>Marker-Farbe (3+ WE):</label>
        <input type="color" id="colorWE3" value="#333333">
        <button onclick="applyCustomColors()">Farben anwenden</button>
      </div>
      <div class="section">
        <h3>Datenverwaltung</h3>
        <button onclick="clearLocalStorage()">Daten löschen</button>
      </div>
    </div>
    <div id="map"></div>
  </div>
  <div id="loading">Adressen werden importiert...</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script>
    function showError(message) {
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
      setTimeout(() => errorDiv.style.display = 'none', 7000);
      console.error('Fehler:', message);
    }
    function showSuccess(message) {
      const successDiv = document.getElementById('success');
      successDiv.textContent = message;
      successDiv.style.display = 'block';
      setTimeout(() => successDiv.style.display = 'none', 6000);
      console.log('OK:', message);
    }

    let map;
    try {
      map = L.map('map').setView([51.1657, 10.4515], 6);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap', maxZoom: 19 }).addTo(map);
    } catch (e) { showError('Fehler beim Initialisieren der Karte: ' + (e.message || e)); }

    let drawnItems = new L.FeatureGroup();
    let markerClusterGroup = L.markerClusterGroup({ disableClusteringAtZoom: 15, maxClusterRadius: 50 });
    if (map) { map.addLayer(drawnItems); map.addLayer(markerClusterGroup); map.addControl(new L.Control.Draw({ draw: { polygon: true, polyline: false, rectangle: false, circle: false, marker: false, circlemarker: false }, edit: { featureGroup: drawnItems } })); }

    let addresses = []; let markers = []; let polygons = []; let employees = []; let failedAddresses = [];
    const polygonColors = ['#0000FF', '#008000', '#800080', '#FFA500', '#00CED1'];
    let colorWE1 = '#87CEEB', colorWE2 = '#0000FF', colorWE3 = '#333333';

    function loadFromLocalStorage() {
      try {
        const savedAddresses = localStorage.getItem('addresses');
        const savedEmployees = localStorage.getItem('employees');
        const savedPolygons = localStorage.getItem('polygons');
        if (savedAddresses) {
          addresses = JSON.parse(savedAddresses);
          addresses.forEach((addr, i) => {
            if (addr.lat && addr.lon && map) {
              const we = addr.WE; const color = we === 1 ? colorWE1 : we === 2 ? colorWE2 : colorWE3;
              const marker = L.circleMarker([addr.lat, addr.lon], { radius: 5, color, fillOpacity: 0.8 });
              marker.bindPopup(createPopupContent(addr, i)); markerClusterGroup.addLayer(marker); markers.push(marker); addr.originalColor = color;
            }
          });
          if (markers.length > 0 && map) map.fitBounds(markerClusterGroup.getBounds());
        }
        if (savedEmployees) { employees = JSON.parse(savedEmployees); updateEmployeeSelect(); }
        if (savedPolygons) {
          polygons = JSON.parse(savedPolygons);
          polygons.forEach((poly) => { const layer = L.polygon(poly.latlngs, { color: poly.color }).addTo(drawnItems); layer.employee = poly.employee; layer.polygonId = poly.polygonId; });
          updatePolygonSelect();
        }
        updateWohneinheitenCount();
      } catch (e) { showError('Fehler beim Laden: ' + (e.message || e)); }
    }

    function saveToLocalStorage() {
      try {
        localStorage.setItem('addresses', JSON.stringify(addresses));
        localStorage.setItem('employees', JSON.stringify(employees));
        localStorage.setItem('polygons', JSON.stringify(polygons.map(poly => ({ employee: poly.employee, latlngs: poly.layer.getLatLngs(), color: poly.layer.options.color, polygonId: poly.polygonId }))));
      } catch (e) { showError('Fehler beim Speichern: ' + (e.message || e)); }
    }

    function addEmployee() {
      const name = document.getElementById('employeeName').value.trim();
      if (!name) return showError('Bitte einen Mitarbeiternamen eingeben.');
      employees.push(name); updateEmployeeSelect(); document.getElementById('employeeName').value=''; saveToLocalStorage();
    }
    function updateEmployeeSelect() { const select = document.getElementById('employeeSelect'); select.innerHTML = '<option value="">Mitarbeiter auswählen</option>'; employees.forEach(name => { const o = document.createElement('option'); o.value = name; o.textContent = name; select.appendChild(o); }); }
    function updatePolygonSelect() { const select = document.getElementById('polygonSelect'); select.innerHTML = '<option value="">Polygon auswählen</option>'; polygons.forEach((p) => { const o = document.createElement('option'); o.value = p.polygonId; o.textContent = `Polygon für ${p.employee}`; select.appendChild(o); }); }

    function createPopupContent(addr, index) {
      const fullAddress = `${addr.Straße} ${addr.Nummer}${addr.Zusatz ? ' ' + addr.Zusatz : ''}, ${addr.PLZ} ${addr.Ort}, Deutschland`;
      return `<div><b>${fullAddress}</b><br>Wohneinheiten: ${addr.WE}<br>
        <select id="assignEmployee${index}"><option value="">Mitarbeiter auswählen</option>${employees.map(emp => `<option value="${emp}">${emp}</option>`).join('')}</select>
        <button onclick="assignEmployeeToAddress(${index})">Zuweisen</button><br>
        <button onclick="editAddress(${index})">Adresse bearbeiten</button></div>`;
    }
    function assignEmployeeToAddress(index){ const select = document.getElementById(`assignEmployee${index}`); const employee = select.value; if(!employee) return showError('Bitte einen Mitarbeiter auswählen.'); const polygon = polygons.find(p=>p.employee===employee); if(!polygon) return showError('Kein Polygon für diesen Mitarbeiter gefunden.'); const addr = addresses[index]; const isInside = isPointInPolygon(addr.lat, addr.lon, polygon.layer); if(!isInside) return showError('Adresse liegt nicht im Polygon dieses Mitarbeiters.'); addr.employee = employee; saveToLocalStorage(); showSuccess(`Adresse ${addr.Straße} ${addr.Nummer} wurde ${employee} zugewiesen.`); }
    function editAddress(index){ const addr=addresses[index]; const newPLZ=prompt('Neue PLZ:', addr.PLZ); const newOrt=prompt('Neuer Ort:', addr.Ort); const newStr=prompt('Neue Straße:', addr.Straße); const newNum=prompt('Neue Nummer:', addr.Nummer); const newZus=prompt('Neuer Zusatz:', addr.Zusatz); const newWE=prompt('Neue Wohneinheiten:', addr.WE); if(newPLZ&&newOrt&&newStr&&newNum&&newWE){ addr.PLZ=newPLZ; addr.Ort=newOrt; addr.Straße=newStr; addr.Nummer=newNum; addr.Zusatz=newZus||''; addr.WE=parseInt(newWE)||1; const fullAddress=`${addr.Straße} ${addr.Nummer}${addr.Zusatz?' '+addr.Zusatz:''}, ${addr.PLZ} ${addr.Ort}, Deutschland`; geocodeAddress(fullAddress, index, true); saveToLocalStorage(); } else { showError('Bitte alle Felder ausfüllen.'); } }

    // Hilfsfunktionen für bessere Geokodierung
    function normGerman(s){ if(!s) return ''; return String(s).toLowerCase().replace(/ß/g,'ss').replace(/ä/g,'ae').replace(/ö/g,'oe').replace(/ü/g,'ue').replace(/\./g,' ').replace(/\s+/g,' ').trim(); }
    function streetVariants(str){ const s = String(str||'').trim(); const base = s.replace(/str\.?\b/gi,'straße').replace(/strasse/gi,'straße'); const ascii = normGerman(base); const alt1 = base.replace(/straße/gi,'strasse'); const alt2 = base.replace(/straße/gi,'str'); return Array.from(new Set([base, alt1, alt2, ascii])); }
    function pickBestCandidate(cands, street, plz, hnr){ if(!Array.isArray(cands)||cands.length===0) return null; const ns = normGerman(street); const nh = String(hnr||'').trim(); let best = null; let bestScore = -1; for(const c of cands){ let sc=0; const addr=c.address||{}; if(addr.postcode && String(addr.postcode).trim()===String(plz).trim()) sc+=3; if(addr.road && normGerman(addr.road).includes(ns)) sc+=3; if(addr.house_number && String(addr.house_number).trim()===nh) sc+=2; if(c.importance) sc+=c.importance; if(sc>bestScore){ best=c; bestScore=sc; } } return best || cands[0]; }

    // Stadt-Cache für Bias (Viewbox)
    const cityBiasCache = {};
    async function getCityBias(plz, ort){
      try{
        const key = `${plz}|${ort}`.toLowerCase();
        if(cityBiasCache[key]) return cityBiasCache[key];
        const url = `https://nominatim.openstreetmap.org/search?format=json&limit=1&addressdetails=1&countrycodes=de&accept-language=de&city=${encodeURIComponent(ort)}&postalcode=${encodeURIComponent(plz||'')}`;
        const resp = await fetch(url, { headers: { 'User-Agent':'QualiDashboard-Polygontool/1.0 (contact: info@jl-dashboard.de)' } });
        const arr = await resp.json();
        if(Array.isArray(arr) && arr.length>0){
          const bb = arr[0].boundingbox; // [south, north, west, east]
          if(bb && bb.length===4){
            const viewbox = { west: Number(bb[2]), south: Number(bb[0]), east: Number(bb[3]), north: Number(bb[1]) };
            cityBiasCache[key] = viewbox; return viewbox;
          }
        }
        cityBiasCache[key] = null; return null;
      } catch(e){ console.warn('getCityBias error', e); return null; }
    }

    async function geocodeAddress(fullAddress, index, updateMarker=false, retryCount=0){
      const MAX_RETRIES = 2;
      try{
        const cached=localStorage.getItem(`geocode_${fullAddress}`);
        if(cached){ const loc=JSON.parse(cached); addresses[index].lat=loc.lat; addresses[index].lon=loc.lon; if(updateMarker&&markers[index]&&map){ const we=addresses[index].WE; const color=we===1?colorWE1:we===2?colorWE2:colorWE3; markers[index].setLatLng([loc.lat, loc.lon]); markers[index].setStyle({color}); markers[index].bindPopup(createPopupContent(addresses[index], index)); addresses[index].originalColor=color; } return true; }
        const a = addresses[index] || {}; const plz = (a.PLZ||'').toString().replace(/[^0-9]/g,''); const ort = (a.Ort||'').toString().trim(); const str = (a.Straße||'').toString().trim(); const hnr = (a.Nummer||'').toString().trim(); const zus = (a.Zusatz||'').toString().trim();
        
        // Log für Debugging
        console.log(`[Geocode #${index}] Versuche: ${str} ${hnr}, ${plz} ${ort}${retryCount > 0 ? ` (Retry ${retryCount})` : ''}`);
        
        const streetLineFull = `${str} ${hnr}${zus? ' '+zus: ''}`.trim();
        const streetLineNoZus = `${str} ${hnr}`.trim();
        const streetOnly = `${str}`.trim();
        const variants = [streetLineFull, streetLineNoZus, ...streetVariants(str).map(v=>`${v} ${hnr}`.trim()), streetOnly];

        const headers = { 'User-Agent':'QualiDashboard-Polygontool/1.0 (contact: info@jl-dashboard.de)' };
        let found = null;

        // 1) Strukturierte Suche mit limit=10 (erhöht von 5), optionaler Stadt-Viewbox-Bias
        const bias = await getCityBias(plz, ort);
        for(const v of variants){
          let url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&limit=10&countrycodes=de&accept-language=de&street=${encodeURIComponent(v)}&city=${encodeURIComponent(ort)}&postalcode=${encodeURIComponent(plz||'')}`;
          if(bias){
            url += `&viewbox=${bias.west},${bias.north},${bias.east},${bias.south}&bounded=1`;
          }
          try {
            const resp = await fetch(url, { headers });
            if (!resp.ok) {
              console.warn(`[Geocode #${index}] HTTP ${resp.status} für ${v}`);
              continue;
            }
            const arr = await resp.json();
            if(Array.isArray(arr) && arr.length>0){ 
              found = pickBestCandidate(arr, str, plz, hnr); 
              if(found) {
                console.log(`[Geocode #${index}] ✓ Gefunden via strukturiert: ${v}`);
                break; 
              }
            }
          } catch(e) {
            console.warn(`[Geocode #${index}] Fehler bei strukturierter Suche: ${e.message}`);
          }
          await sleep(150); // Kurze Pause zwischen Varianten
        }
        
        // 2) Fallback: Freitext (q) mit mehr Varianten
        if(!found){
          const qVariants = [ 
            `${str} ${hnr}, ${plz} ${ort}, Deutschland`,
            `${str} ${hnr}, ${ort}, Deutschland`,
            `${str}, ${plz} ${ort}, Deutschland`,
            `${plz} ${ort}, ${str} ${hnr}`,
            `${ort}, ${str} ${hnr}`
          ];
          for(const q of qVariants){
            let url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&limit=10&countrycodes=de&accept-language=de&q=${encodeURIComponent(q)}`;
            if(bias){ url += `&viewbox=${bias.west},${bias.north},${bias.east},${bias.south}`; } // bounded=1 entfernt für mehr Flexibilität
            try {
              const resp = await fetch(url, { headers });
              if (!resp.ok) continue;
              const arr = await resp.json();
              if(Array.isArray(arr) && arr.length>0){ 
                found = pickBestCandidate(arr, str, plz, hnr); 
                if(found) {
                  console.log(`[Geocode #${index}] ✓ Gefunden via Freitext: ${q}`);
                  break; 
                }
              }
            } catch(e) {
              console.warn(`[Geocode #${index}] Fehler bei Freitext-Suche: ${e.message}`);
            }
            await sleep(150);
          }
        }
        
        // 3) Letzte Chance: Nur Stadt + PLZ für ungefähre Position
        if(!found && plz && ort){
          const fallbackQ = `${plz} ${ort}, Deutschland`;
          const url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&limit=1&countrycodes=de&accept-language=de&q=${encodeURIComponent(fallbackQ)}`;
          try {
            const resp = await fetch(url, { headers });
            const arr = await resp.json();
            if(Array.isArray(arr) && arr.length>0){ 
              found = arr[0];
              console.log(`[Geocode #${index}] ⚠ Nur Stadt gefunden (ungenau): ${fallbackQ}`);
              addresses[index].geocodeApproximate = true; // Markierung für ungenaue Geokodierung
            }
          } catch(e) {
            console.warn(`[Geocode #${index}] Fehler bei Stadt-Fallback: ${e.message}`);
          }
        }

        if(found){
          addresses[index].lat = parseFloat(found.lat); addresses[index].lon = parseFloat(found.lon);
          localStorage.setItem(`geocode_${fullAddress}`, JSON.stringify({ lat: addresses[index].lat, lon: addresses[index].lon }));
          if(updateMarker&&markers[index]&&map){ const we=addresses[index].WE; const color=we===1?colorWE1:we===2?colorWE2:colorWE3; markers[index].setLatLng([addresses[index].lat, addresses[index].lon]); markers[index].setStyle({color}); markers[index].bindPopup(createPopupContent(addresses[index], index)); addresses[index].originalColor=color; }
          return true;
        }
        
        // Retry bei Fehler
        if(retryCount < MAX_RETRIES) {
          console.log(`[Geocode #${index}] Retry nach 2 Sekunden...`);
          await sleep(2000);
          return await geocodeAddress(fullAddress, index, updateMarker, retryCount + 1);
        }
        
        console.error(`[Geocode #${index}] ✗ FAILED nach ${retryCount + 1} Versuchen: ${fullAddress}`);
        return false;
      } catch(e){ 
        console.error(`[Geocode #${index}] Exception:`, e);
        // Retry bei Exception
        if(retryCount < MAX_RETRIES) {
          await sleep(2000);
          return await geocodeAddress(fullAddress, index, updateMarker, retryCount + 1);
        }
        return false; 
      }
    }
    
    // Sleep helper
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // === Toleranter Excel-Import ===
    function normalizeHeader(h){ if(!h) return ''; let s=String(h).trim().toLowerCase(); s=s.normalize('NFD').replace(/[\u0300-\u036f]/g,''); // diacritics raus
      s=s.replace(/\./g,'').replace(/\s+/g,' ');
      s=s.replace('strasse','straße'); // Sonderfall
      return s; }
    const aliasMap = {
      'plz':'PLZ','postleitzahl':'PLZ',
      'ort':'Ort','stadt':'Ort','gemeinde':'Ort',
      'straße':'Straße','strasse':'Straße','str':'Straße','strasse name':'Straße','strassenname':'Straße','strassenbezeichnung':'Straße','strassen':'Straße',
      'hausnummer':'Nummer','hnr':'Nummer','nr':'Nummer','nummer':'Nummer','haus nr':'Nummer','hausnr':'Nummer',
      'zusatz':'Zusatz','adresszusatz':'Zusatz','adresszus':'Zusatz','zus':'Zusatz','etage':'Zusatz','stock':'Zusatz',
      'we':'WE','wohneinheiten':'WE','wohneinheit':'WE','anz we':'WE','anzahl we':'WE','anzahl wohneinheiten':'WE'
    };
    function detectHeaderMap(rows){
      // rows: array of arrays
      const maxScan = Math.min(rows.length, 25);
      let best = { idx: -1, map: {}, score: -1 };
      for(let r=0;r<maxScan;r++){
        const row = rows[r] || [];
        const map = {}; let score = 0;
        row.forEach((cell, idx)=>{
          const n=normalizeHeader(cell); if(!n) return; const canon = aliasMap[n] || null; if(canon && !Object.values(map).includes(canon)){ map[idx]=canon; score++; }
        });
        if(score > best.score){ best = { idx:r, map, score } }
      }
      return best;
    }

    async function importExcel(){ const file = document.getElementById('excelInput').files[0]; if(!file) return showError('Bitte eine Excel-Datei auswählen.');
      try{
        document.getElementById('loading').style.display='block';
        markerClusterGroup.clearLayers(); markers=[]; addresses=[]; failedAddresses=[];
        const data = await file.arrayBuffer();
        const wb = XLSX.read(data, { type:'array' }); const sheet = wb.Sheets[wb.SheetNames[0]]; if(!sheet) throw new Error('Kein Arbeitsblatt gefunden.');
        const rows = XLSX.utils.sheet_to_json(sheet, { header:1, blankrows:false, defval:'' });
        if(!rows || rows.length===0) throw new Error('Leere Tabelle.');
        const best = detectHeaderMap(rows);
        const headerIdx = best.idx >= 0 ? best.idx : 0;
        const map = best.map || {};
        // Pflichtfelder (Zusatz optional)
        const required = ['PLZ','Ort','Straße','Nummer','WE'];
        const mappedCanon = new Set(Object.values(map));
        const missing = required.filter(k=>!mappedCanon.has(k));
        if(missing.length){
          // Versuche Fallback mit erster Zeile direkt
          const headerRow = rows[headerIdx];
          const headersDebug = (headerRow||[]).map(h=>String(h)).join(' | ');
          document.getElementById('loading').style.display='none';
          return showError('Spalten erkannt: '+Array.from(mappedCanon).join(', ')+' — Fehlend: '+missing.join(', ')+'\nHinweis: Mögliche Aliase: Straße/Strasse/Str., Nummer/Hausnummer, WE/Wohneinheiten.\nGefundene Kopfzeile: '+headersDebug);
        }
        // Zusatz optional: wenn nicht gemappt, bleibt undefined und wird als '' gesetzt
        // Baue Datensätze
        for(let r=headerIdx+1;r<rows.length;r++){
          const row = rows[r] || [];
          const obj = { PLZ:'', Ort:'', Straße:'', Nummer:'', Zusatz:'', WE:1 };
          Object.keys(map).forEach(colIdx=>{
            const canon = map[colIdx]; const val = row[Number(colIdx)];
            if(canon==='WE'){
              const n = parseInt(String(val).toString().replace(/[^0-9]/g,''),10);
              obj.WE = Number.isFinite(n) && n>0 ? n : 1; // Default 1
            } else if(canon){ obj[canon] = String(val||'').trim(); }
          });
          // Sanity: Mindestfelder müssen befüllt sein
          if(obj.PLZ||obj.Ort||obj.Straße||obj.Nummer){ addresses.push(obj); }
        }
        // Geokodierung sequentiell (stabiler als parallel)
        let geocodedCount=0;
        console.log(`[Import] Starte Geokodierung von ${addresses.length} Adressen...`);
        
        for(let i=0; i<addresses.length; i++){
          const address = addresses[i];
          const fullAddress = `${address.Straße} ${address.Nummer}${address.Zusatz?' '+address.Zusatz:''}, ${address.PLZ} ${address.Ort}, Deutschland`;
          
          // Update loading message
          document.getElementById('loading').textContent = `Geokodiere ${i+1}/${addresses.length}: ${address.Straße} ${address.Nummer}, ${address.Ort}...`;
          
          const success = await geocodeAddress(fullAddress, i);
          
          if(success && map){ 
            const we=address.WE; 
            const color=we===1?colorWE1:we===2?colorWE2:colorWE3; 
            const marker=L.circleMarker([address.lat,address.lon],{radius:5,color,fillOpacity:0.8}); 
            marker.bindPopup(createPopupContent(address,i)); 
            markerClusterGroup.addLayer(marker); 
            markers.push(marker); 
            address.originalColor=color; 
            geocodedCount++; 
          } else { 
            console.warn(`[Import] Failed: ${fullAddress}`);
            failedAddresses.push({ index:i, address }); 
          }
          
          // Längere Pause zwischen Anfragen (Nominatim rate limit: 1 request/second)
          await sleep(1200);
        }
        
        console.log(`[Import] Fertig: ${geocodedCount}/${addresses.length} erfolgreich geokodiert, ${failedAddresses.length} fehlgeschlagen`);
        document.getElementById('loading').textContent = 'Adressen werden importiert...';
        if(failedAddresses.length>0) displayFailedAddresses();
        if(markers.length>0 && map){ map.fitBounds(markerClusterGroup.getBounds()); showSuccess(`Adressimport abgeschlossen: ${geocodedCount} Adressen auf der Karte.`); } else { showError('Keine Adressen konnten geokodiert werden.'); }
        saveToLocalStorage(); updateWohneinheitenCount(); document.getElementById('loading').style.display='none';
      } catch(e){ document.getElementById('loading').style.display='none'; showError('Fehler beim Verarbeiten der Excel-Datei: '+(e.message||e)); }
    }

    function displayFailedAddresses(){ const failedDiv=document.getElementById('failedAddresses'); failedDiv.innerHTML = '<h4 style="font-size: 12px; margin: 2px 0;">Nicht geokodierte Adressen</h4>'; failedAddresses.forEach(({index,address})=>{ const full=`${address.Straße} ${address.Nummer}${address.Zusatz?' '+address.Zusatz:''}, ${address.PLZ} ${address.Ort}, Deutschland`; const div=document.createElement('div'); div.className='failed-address'; div.innerHTML = `<p>${full}</p><input type="text" id="lat${index}" placeholder="Breitengrad"><input type="text" id="lon${index}" placeholder="Längengrad"><button onclick="addManualCoordinates(${index})">Hinzufügen</button><button onclick="skipAddress(${index})">Überspringen</button>`; failedDiv.appendChild(div); }); failedDiv.style.display='block'; }
    function addManualCoordinates(index){ const lat=parseFloat(document.getElementById(`lat${index}`).value); const lon=parseFloat(document.getElementById(`lon${index}`).value); if(isNaN(lat)||isNaN(lon)) return showError('Bitte gültige Koordinaten eingeben.'); const address=addresses[index]; address.lat=lat; address.lon=lon; const we=address.WE; const color=we===1?colorWE1:we===2?colorWE2:colorWE3; const marker=L.circleMarker([lat,lon],{radius:5,color,fillOpacity:0.8}); marker.bindPopup(createPopupContent(address,index)); markerClusterGroup.addLayer(marker); markers[index]=marker; address.originalColor=color; failedAddresses = failedAddresses.filter(f=>f.index!==index); if(failedAddresses.length===0) document.getElementById('failedAddresses').style.display='none'; else displayFailedAddresses(); saveToLocalStorage(); updateWohneinheitenCount(); showSuccess('Koordinaten hinzugefügt.'); }
    function skipAddress(index){ failedAddresses = failedAddresses.filter(f=>f.index!==index); if(failedAddresses.length===0) document.getElementById('failedAddresses').style.display='none'; else displayFailedAddresses(); }

    if(map){ map.on('draw:created', function(e){ const employee=document.getElementById('employeeSelect').value; if(!employee) return showError('Bitte einen Mitarbeiter auswählen, bevor ein Polygon gezeichnet wird.'); const layer=e.layer; const color=polygonColors[polygons.length % polygonColors.length]; layer.setStyle({color}); const polygonId=Date.now().toString(); layer.employee=employee; layer.polygonId=polygonId; polygons.push({ layer, employee, polygonId }); drawnItems.addLayer(layer); updatePolygonSelect(); saveToLocalStorage(); updateWohneinheitenCount(); }); map.on('draw:edited', function(){ saveToLocalStorage(); updateWohneinheitenCount(); }); }

    function highlightPolygon(){ const polygonId=document.getElementById('polygonSelect').value; polygons.forEach(p=>{ p.layer.setStyle({ weight: p.polygonId===polygonId ? 5 : 2 }); }); updateWohneinheitenCount(); }
    function deleteSelectedPolygon(){ const polygonId=document.getElementById('polygonSelect').value; if(!polygonId) return showError('Bitte ein Polygon auswählen.'); const index=polygons.findIndex(p=>p.polygonId===polygonId); if(index!==-1){ drawnItems.removeLayer(polygons[index].layer); polygons.splice(index,1); updatePolygonSelect(); saveToLocalStorage(); updateWohneinheitenCount(); } }

    function applyCustomColors(){ colorWE1=document.getElementById('colorWE1').value; colorWE2=document.getElementById('colorWE2').value; colorWE3=document.getElementById('colorWE3').value; addresses.forEach((addr,i)=>{ if(markers[i]){ const we=addr.WE; const color=we===1?colorWE1:we===2?colorWE2:colorWE3; addr.originalColor=color; const isInsideAny=polygons.some(p=>isPointInPolygon(addr.lat, addr.lon, p.layer)); if(!isInsideAny) markers[i].setStyle({color}); }}); saveToLocalStorage(); }
    function clearLocalStorage(){ localStorage.removeItem('addresses'); localStorage.removeItem('employees'); localStorage.removeItem('polygons'); addresses=[]; employees=[]; polygons=[]; markerClusterGroup.clearLayers(); markers=[]; drawnItems.clearLayers(); updateEmployeeSelect(); updatePolygonSelect(); updateWohneinheitenCount(); document.getElementById('failedAddresses').style.display='none'; }

    function isPointInPolygon(lat,lng,polygon){
      try{
        // Use standard ray-casting with x=lng, y=lat
        const point = L.latLng(lat,lng);
        const rings = polygon.getLatLngs();
        const polyPoints = Array.isArray(rings[0]) ? rings[0] : rings; // handle simple polygon
        const bounds = L.polygon(polyPoints).getBounds();
        if(!bounds.contains(point)) return false;
        const x = lng; const y = lat;
        let inside=false;
        for(let i=0,j=polyPoints.length-1;i<polyPoints.length;j=i++){
          const xi = polyPoints[i].lng, yi = polyPoints[i].lat; // x=lng, y=lat
          const xj = polyPoints[j].lng, yj = polyPoints[j].lat;
          const intersect = ((yi>y)!==(yj>y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
          if(intersect) inside = !inside;
        }
        return inside;
      }catch(e){ console.error('PointInPolygon error', e); return false; }
    }

    function updateWohneinheitenCount(){
      const polygonId=document.getElementById('polygonSelect').value;
      const selectedPolygon=polygons.find(p=>p.polygonId===polygonId);
      if(!selectedPolygon){
        document.getElementById('weCount').textContent='Wohneinheiten im Polygon: 0';
        addresses.forEach((addr,i)=>{ if(markers[i]&&addr.originalColor) markers[i].setStyle({color:addr.originalColor}); });
        return;
      }
      const rings = selectedPolygon.layer.getLatLngs();
      const coords = Array.isArray(rings[0]) ? rings[0] : rings;
      if(!coords||coords.length<3) return showError('Ungültiges Polygon: Mindestens 3 Punkte erforderlich.');
      let totalWE=0;
      addresses.forEach((addr,i)=>{
        if(addr.lat&&addr.lon){
          const inside=isPointInPolygon(addr.lat, addr.lon, selectedPolygon.layer);
          if(markers[i]) markers[i].setStyle({color: inside ? '#FF0000' : (addr.originalColor||'#000')});
          if(inside){ totalWE += (Number.isFinite(addr.WE)?addr.WE:1); }
        }
      });
      document.getElementById('weCount').textContent = `Wohneinheiten im Polygon: ${totalWE}`;
    }

    function testCSVExport(){ const dummy=[ {PLZ:'10115',Ort:'Berlin',Straße:'Hauptstraße',Nummer:'1',Zusatz:'A',WE:5}, {PLZ:'80331',Ort:'München',Straße:'Bahnhofstraße',Nummer:'10',Zusatz:'',WE:3} ]; exportAsCSV(dummy,'Test_Adressen.csv'); }
    function exportAsCSV(data, filename){ try{ const headers=['PLZ','Ort','Straße','Nummer','Zusatz','WE']; const esc=v=>{ if(v==null) return ''; return '"'+String(v).replace(/"/g,'""').replace(/\n/g,' ')+'"'; }; const csv=[ headers.join(','), ...data.map(r=>headers.map(h=>esc(r[h])).join(',')) ].join('\n'); const ta=document.getElementById('csvOutput'); ta.value=csv; ta.style.display='block'; const BOM='\uFEFF'; const blob=new Blob([BOM+csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const link=document.createElement('a'); link.href=url; link.download=filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); } catch(e){ showError('Fehler beim CSV-Export: '+(e.message||e)); } }
    function exportPolygonAddresses(){ const polygonId=document.getElementById('polygonSelect').value; if(!polygonId) return showError('Bitte ein Polygon auswählen.'); const polygon=polygons.find(p=>p.polygonId===polygonId); if(!polygon) return showError('Ausgewähltes Polygon nicht gefunden.'); const filtered=addresses.filter((addr,i)=> addr.lat&&addr.lon&&isPointInPolygon(addr.lat, addr.lon, polygon.layer)); if(filtered.length===0) return showError('Keine Adressen im Polygon gefunden.'); const exportData=filtered.map(addr=>({ PLZ:String(addr.PLZ||''), Ort:String(addr.Ort||''), Straße:String(addr.Straße||''), Nummer:String(addr.Nummer||''), Zusatz:String(addr.Zusatz||''), WE:Number.isFinite(addr.WE)?addr.WE:1 })); exportAsCSV(exportData, `${polygon.employee}_Adressen.csv`); }
    function updatePolygonAssignment(){ updateWohneinheitenCount(); }

    loadFromLocalStorage();
  </script>
</body>
</html>
